<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Processing UK 2021 census open data with python tools |</title><meta name=keywords content="python,geospatial,census"><meta name=description content="Introduction The census provides a rich set of demographic information that could be useful for various data science tasks, such as geomarketing, house price analysis etc. With the results of the 2021 census being published recently, this notebook demonstrates how to manipulate this data with FOSS python tools to build a dataset that can be used for downstream tasks.
For this demo, I will be focusing on output areas (OA) of London:"><meta name=author content="Wendy Mak"><link rel=canonical href=https://wwymak.github.io/tech/2023-02-01-uk-population-census-2021/><link crossorigin=anonymous href=https://wwymak.github.io/assets/css/stylesheet.bccfefac377bc340f06c260aed1bddf49a4354816d7c570d6aac75a997986c95.css integrity="sha256-vM/vrDd7w0DwbCYK7Rvd9JpDVIFtfFcNaqx1qZeYbJU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=https://wwymak.github.io/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://wwymak.github.io/avatar.png><link rel=icon type=image/png sizes=16x16 href=https://wwymak.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wwymak.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wwymak.github.io/apple-touch-icon.png><link rel=mask-icon href=https://wwymak.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Processing UK 2021 census open data with python tools"><meta property="og:description" content="Introduction The census provides a rich set of demographic information that could be useful for various data science tasks, such as geomarketing, house price analysis etc. With the results of the 2021 census being published recently, this notebook demonstrates how to manipulate this data with FOSS python tools to build a dataset that can be used for downstream tasks.
For this demo, I will be focusing on output areas (OA) of London:"><meta property="og:type" content="article"><meta property="og:url" content="https://wwymak.github.io/tech/2023-02-01-uk-population-census-2021/"><meta property="article:section" content="tech"><meta property="article:published_time" content="2023-01-14T18:54:32+00:00"><meta property="article:modified_time" content="2023-02-02T13:41:14+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Processing UK 2021 census open data with python tools"><meta name=twitter:description content="Introduction The census provides a rich set of demographic information that could be useful for various data science tasks, such as geomarketing, house price analysis etc. With the results of the 2021 census being published recently, this notebook demonstrates how to manipulate this data with FOSS python tools to build a dataset that can be used for downstream tasks.
For this demo, I will be focusing on output areas (OA) of London:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"","item":"https://wwymak.github.io/tech/"},{"@type":"ListItem","position":3,"name":"Processing UK 2021 census open data with python tools","item":"https://wwymak.github.io/tech/2023-02-01-uk-population-census-2021/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Processing UK 2021 census open data with python tools","name":"Processing UK 2021 census open data with python tools","description":"Introduction The census provides a rich set of demographic information that could be useful for various data science tasks, such as geomarketing, house price analysis etc. With the results of the 2021 census being published recently, this notebook demonstrates how to manipulate this data with FOSS python tools to build a dataset that can be used for downstream tasks.\nFor this demo, I will be focusing on output areas (OA) of London:","keywords":["python","geospatial","census"],"articleBody":"Introduction The census provides a rich set of demographic information that could be useful for various data science tasks, such as geomarketing, house price analysis etc. With the results of the 2021 census being published recently, this notebook demonstrates how to manipulate this data with FOSS python tools to build a dataset that can be used for downstream tasks.\nFor this demo, I will be focusing on output areas (OA) of London:\ndownload the boundaries for these OA download demographics datasets (population, household size, gender, education level) convert the irregular geometries of the OA into 100m by 100m cells calculate the avgerages for the demographics per bin convert the cell data into raster These are the packages we will need:\nimport pandas as pd import geopandas as gpd from shapely.geometry import Polygon import numpy as np from tqdm import tqdm import fiona import rasterio as rio from geocube.api.core import make_geocube Datasets Population data for Census 2021 according to Output Area (https://www.ons.gov.uk/filters/b9532b29-299e-4a23-9fc8-b99d68e172b9/dimensions)\nTitle: Population density Description: This dataset provides Census 2021 estimates that classify usual residents in England and Wales by population density (number of usual residents per square kilometre). The estimates are as at Census Day, 21 March 2021.\nOutput Areas (OAs) are the lowest level of geographical area for census statistics and were first created following the 2001 Census. Each OA is made up of between 40 and 250 households and a usually resident population of between 100 and 625 persons and may change after each census.\npopulation_oa = pd.read_csv('data/uk-census-2021-oa.csv') population_oa.head() .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Geographic manipulation– OA boundaries to cells To match the above OA codes with actual geography, we have to obtain the boundaries of each output area– these can be found on UK’s goverment geoportal– note that I am using the ‘generalised’ version instead of the full version.\nboundaries = gpd.read_file('data/Output_Areas_(Dec_2021)_Boundaries_Generalised_Clipped_EW_(BGC)/Output_Areas_(Dec_2021)_Boundaries_Generalised_Clipped_EW_(BGC).shp') boundaries.head() .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } In the boundaries geodataframe, the columns we’ll need is that ‘OA21CD’, ‘Shape_Are’ and ‘geometry columns’: ‘OA21CD’ can join to the population dataset from above, Shape__Are gives the area of the OA in m^2 (note that this is different from the poulation measurement unit, which is in km^2). We can in fact cross check it against the geometry column\n# check that the projection is indeed british national grid eastings and northings print(f\"geodata has projection of {boundaries.crs}\") # check that the geometry gives ~the same area as what shape_are gives to a 10m^2 tolerance assert ((boundaries.area.astype(int)- boundaries.Shape__Are.astype(int)).abs() \u003c 10).sum() == len(boundaries) geodata has projection of epsg:27700 Since we are only interested in Greater London, we can filter out rows from the boundaries dataframe that are outside of the london bounding box.\nWe can get the bounding box of london using the OSM query https://nominatim.openstreetmap.org/search.php?city=london\u0026country=uk\u0026format=jsonv2 (the first entry is the correct one), giving a boundingbox of ymin, ymax, xmin, xmax of “51.2867602”,“51.6918741”,\"-0.5103751\",“0.3340155”\nldn_bounding_box = Polygon.from_bounds( -0.5103751, 51.2867602,0.3340155, 51.691874 ) ldn_bounding_box = gpd.GeoSeries([ldn_bounding_box], crs='epsg:4326').to_crs(boundaries.crs) ldn_bounding_box.geometry 0 POLYGON ((503976.311 155234.131, 503059.759 20... dtype: geometry Convert the geodataframe into a grid for downstream tasks– Ordnance survey actually has a file of british grids at various resolutions prebuilt (https://github.com/OrdnanceSurvey/OS-British-National-Grids), – the smallest is 1km by 1km, so we will construct our own 100m x 100m grid for london (We can do it for the whole uk, but we will have to iterate through the dataset as the number of cells will become very large)\ndiversion\nThis demos how to use the grid gpkg file from OS– the gpkg is a vector file with multiple ’layers’ the same way a raster file can have bands\n# get the layer names list(fiona.listlayers('data/os_bng_grids.gpkg')) ['100km_grid', '50km_grid', '20km_grid', '10km_grid', '5km_grid', '1km_grid'] layername = '1km_grid' bsng_grid_1km = gpd.read_file('data/os_bng_grids.gpkg', layer=layername) bsng_grid_1km.head() .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Back to our task, we filter out the OA that intersects the london bounding box:\ngpd.GeoDataFrame(ldn_bounding_box.reset_index()).geometry 0 POLYGON ((503976.311 155234.131, 503059.759 20... Name: 0, dtype: geometry ldn_boundaries = boundaries[['OA21CD', 'geometry']].sjoin(gpd.GeoDataFrame(ldn_bounding_box.reset_index()), how='inner')[['OA21CD', 'geometry']] ldn_boundaries.head() .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } ldn_bounding_box.geometry[0].bounds (503059.75944664044, 155234.13110756868, 562854.9611320551, 201813.5769950911) # create a 100m by 100m grid for london cellsize=100 # British National Grid extent (0,0 700000,1300000) xmin, ymin, xmax, ymax = [100 * (x//100 )for x in ldn_bounding_box.geometry[0].bounds] matrix = np.mgrid[int(xmin):int(xmax + cellsize):cellsize, int(ymin):int(ymax+ cellsize):cellsize] xcoor = matrix[0].flatten() ycoor = matrix[1].flatten() xcoor_max = xcoor +cellsize ycoor_max = ycoor + cellsize polygons = [] for x, y, xmax, ymax in tqdm(zip (xcoor, ycoor, xcoor_max, ycoor_max), total=len(ycoor)): polygons.append(Polygon.from_bounds(x, y, xmax, ymax)) grid = gpd.GeoDataFrame(data={'cellid': np.arange(len(polygons))},geometry=polygons, crs=boundaries.crs) 100%|████████████████████████████████| 279733/279733 [00:04\u003c00:00, 65379.51it/s] Join the grid to the OA polygons to get the demographics info per grid cell\nprint(grid.shape) print(ldn_boundaries.shape) ldn_demographics_grid = grid.sjoin(boundaries) (279733, 2) (30160, 2) ldn_demographics_grid .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } # as we can see, the OA size span is quite large --luckily most OA are larger than a grid cell. ax =ldn_demographics_grid.drop_duplicates(subset='OA21CD').Shape__Are.apply(np.log10).hist(bins = 100) ax.set_xlabel('OA area m^2') ax.set_ylabel('number of OA') ax.vlines(4,0,1800, colors='b', label='10,000 m^2 (Size of cell)') ax.legend() There are clearly duplicates– e.g. when a grid cell span more than 1 OA, and where 1OA span more than 1cell– this is more likely for the OA to span mutliple cells than the other way round. Base on this assumption, we assign each cell to one OA by dropping duplicadtes\nldn_demographics_grid = ldn_demographics_grid.drop_duplicates(subset='cellid') # drop all the unneed cols ldn_demographics_grid = ldn_demographics_grid[['cellid', 'OA21CD', 'geometry']] Finally, let’s populate these grid cells with demographic data\nhousehold size by OA education [population density]((https://www.ons.gov.uk/filters/b9532b29-299e-4a23-9fc8-b99d68e172b9/dimensions) sex We have discussed the population data above, let’s now tidy up the other datasets\nhousehold size houshold = pd.read_csv('data/household_size_output_area_census2021.csv') houshold.head() .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } We can use the ‘code’ as a proxy for household size\nhoushold[['Household size (9 categories)', 'Household size (9 categories) Code']].drop_duplicates() .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } mean_household_size = houshold[['Output Areas Code', 'Household size (9 categories) Code','Observation']] mean_household_size['counts'] = mean_household_size['Household size (9 categories) Code'] * mean_household_size['Observation'] mean_household_size = mean_household_size.groupby('Output Areas Code')['counts'].sum() mean_household_size_totals = houshold[['Output Areas Code', 'Household size (9 categories) Code','Observation']].groupby('Output Areas Code')['Observation'].sum() /tmp/ipykernel_28838/2961719914.py:2: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy mean_household_size['counts'] = mean_household_size['Household size (9 categories) Code'] * mean_household_size['Observation'] mean_household_size.reset_index() .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } mean_household_size = mean_household_size.reset_index().merge(mean_household_size_totals.reset_index(), on='Output Areas Code') mean_household_size['avg_household_size'] = mean_household_size['counts'] / mean_household_size['Observation'] mean_household_size.head() .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } gender gender = pd.read_csv('data/uk-census-2021-sex-oa.csv') gender.head() .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } females = gender[gender['Sex (2 categories)'] == 'Female'] gender_total = gender.groupby(['Output Areas Code'])['Observation'].sum().reset_index() percent_female = females[['Output Areas', 'Observation']].merge(gender_total, left_on='Output Areas', right_on='Output Areas Code') percent_female['pct'] = percent_female['Observation_x'] / percent_female['Observation_y'] percent_female.head() .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } education education = pd.read_csv('data/uk-census-2021-education-oa.csv') education.head() .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } education[['Highest level of qualification (8 categories) Code','Highest level of qualification (8 categories)'\t]].drop_duplicates() .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } here make the simplifying assumption that we ignore the ‘does not apply category’, and the categories code go up in more advanced education\nmean_education_level = education[['Output Areas Code', 'Highest level of qualification (8 categories) Code','Observation']] mean_education_level['counts'] = mean_education_level['Highest level of qualification (8 categories) Code'].clip(lower=0) * mean_education_level['Observation'] mean_education_level = mean_education_level.groupby('Output Areas Code')['counts'].sum() mean_education_level_totals = education[['Output Areas Code', 'Highest level of qualification (8 categories) Code','Observation']].groupby('Output Areas Code')['Observation'].sum() mean_education_level = mean_education_level.reset_index().merge(mean_education_level_totals.reset_index(), on='Output Areas Code') mean_education_level['avg_education_level'] = mean_education_level['counts'] / mean_education_level['Observation'] mean_education_level.head() /tmp/ipykernel_28838/566605148.py:2: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy mean_education_level['counts'] = mean_education_level['Highest level of qualification (8 categories) Code'].clip(lower=0) * mean_education_level['Observation'] .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } # add education level info ldn_demographics_grid_processed = ldn_demographics_grid.merge(mean_education_level[[ 'Output Areas Code', 'avg_education_level']], left_on='OA21CD', right_on='Output Areas Code').drop(columns='Output Areas Code') # add % female ldn_demographics_grid_processed = ldn_demographics_grid_processed.merge(percent_female[[ 'Output Areas Code', 'pct']], left_on='OA21CD', right_on='Output Areas Code').drop(columns='Output Areas Code').rename(columns={'pct': 'pct_females'}) # add mean household size ldn_demographics_grid_processed = ldn_demographics_grid_processed.merge(mean_household_size[[ 'Output Areas Code', 'avg_household_size']], left_on='OA21CD', right_on='Output Areas Code').drop(columns='Output Areas Code') ldn_demographics_grid_processed = ldn_demographics_grid_processed.merge(population_oa[[ 'Output Areas Code', 'Observation']], left_on='OA21CD', right_on='Output Areas Code').drop(columns='Output Areas Code').rename( columns={'Observation': 'pop_density'}) ldn_demographics_grid_processed['popoulation'] = ldn_demographics_grid_processed['pop_density'] * (100 * 100)/(1000 * 1000) ldn_demographics_grid_processed.head() .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } ldn_demographics_grid_processed.to_file('data/ldn_demographics_grid_processed.shp') /tmp/ipykernel_28838/324827064.py:1: UserWarning: Column names longer than 10 characters will be truncated when saved to ESRI Shapefile. ldn_demographics_grid_processed.to_file('data/ldn_demographics_grid_processed.shp') Rasterizing geodataframe Certain tools work better with raster data, and since we have converted our data from a irregular geometry into cells, we can go all the way and convert the vector data into raster, using geocube.\nCapping/binning population values\nThe population values have a fairly long tail– let’s cap this so it is easier to plot and handle\n# printing out some stats -- we can see 95% cells have \u003c 150 people ldn_demographics_grid_processed['popoulation'].quantile([0.2, 0.4, 0.6, 0.8]),ldn_demographics_grid_processed['popoulation'].quantile([0.05]), ldn_demographics_grid_processed['popoulation'].quantile([0.95]), ldn_demographics_grid_processed['popoulation'].min(), ldn_demographics_grid_processed['popoulation'].max() (0.2 1.024 0.4 4.157 0.6 21.138 0.8 62.500 Name: popoulation, dtype: float64, 0.05 0.321 Name: popoulation, dtype: float64, 0.95 130.5817 Name: popoulation, dtype: float64, 0.156, 2393.333) ldn_demographics_grid_processed['popoulation'] = ldn_demographics_grid_processed['popoulation'].clip(lower=0, upper=150) ldn_demographics_grid_processed['popoulation'].max() 150.0 Now we convert the vector to raster (the resolution is what we are using for each of our cells– 100m )\nldn_demographics_raster = make_geocube( vector_data=ldn_demographics_grid_processed, measurements=[\"popoulation\", \"avg_education_level\", \"pct_females\"], resolution=(-100, 100), ) ldn_demographics_raster['popoulation'].plot() ldn_demographics_raster['pct_females'].plot() ldn_demographics_raster['avg_education_level'].plot() # save our raster data ldn_demographics_raster.rio.to_raster(\"data/ldn_demographics_raster.tiff\") ","wordCount":"1649","inLanguage":"en","datePublished":"2023-01-14T18:54:32Z","dateModified":"2023-02-02T13:41:14Z","author":{"@type":"Person","name":"Wendy Mak"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wwymak.github.io/tech/2023-02-01-uk-population-census-2021/"},"publisher":{"@type":"Organization","name":"","logo":{"@type":"ImageObject","url":"https://wwymak.github.io/avatar.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wwymak.github.io title=Blog><span>Blog</span></a></li><li><a href=https://wwymak.github.io/bakery title=Bakery><span>Bakery</span></a></li><li><a href=https://wwymak.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://wwymak.github.io/tags title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wwymak.github.io>Home</a>&nbsp;»&nbsp;<a href=https://wwymak.github.io/tech/></a></div><h1 class=post-title>Processing UK 2021 census open data with python tools</h1><div class=post-meta><span title='2023-01-14 18:54:32 +0000 UTC'>January 14, 2023</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Wendy Mak&nbsp;|&nbsp;<a href=https://github.com/wwymak/wwymak.github.io/tree/main/content//tech/2023-02-01-uk-population-census-2021.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h3 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h3><p>The census provides a rich set of demographic information that could be useful for various data science tasks, such as geomarketing, house price analysis etc. With the results of the 2021 census being published recently, this notebook demonstrates how to manipulate this data with FOSS python tools to build a dataset that can be used for downstream tasks.</p><p>For this demo, I will be focusing on output areas (OA) of London:</p><ul><li>download the boundaries for these OA</li><li>download demographics datasets (population, household size, gender, education level)</li><li>convert the irregular geometries of the OA into 100m by 100m cells</li><li>calculate the avgerages for the demographics per bin</li><li>convert the cell data into raster</li></ul><p>These are the packages we will need:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>pandas</span> <span class=k>as</span> <span class=nn>pd</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>geopandas</span> <span class=k>as</span> <span class=nn>gpd</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>shapely.geometry</span> <span class=kn>import</span> <span class=n>Polygon</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>numpy</span> <span class=k>as</span> <span class=nn>np</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>tqdm</span> <span class=kn>import</span> <span class=n>tqdm</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>fiona</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>rasterio</span> <span class=k>as</span> <span class=nn>rio</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>geocube.api.core</span> <span class=kn>import</span> <span class=n>make_geocube</span>
</span></span></code></pre></div><h3 id=datasets>Datasets<a hidden class=anchor aria-hidden=true href=#datasets>#</a></h3><h4 id=population-data>Population data<a hidden class=anchor aria-hidden=true href=#population-data>#</a></h4><p>for Census 2021 according to Output Area (<a href=https://www.ons.gov.uk/filters/b9532b29-299e-4a23-9fc8-b99d68e172b9/dimensions>https://www.ons.gov.uk/filters/b9532b29-299e-4a23-9fc8-b99d68e172b9/dimensions</a>)</p><blockquote><p>Title: Population density
Description: This dataset provides Census 2021 estimates that classify usual residents in England and Wales by population density (number of usual residents per square kilometre). The estimates are as at Census Day, 21 March 2021.</p></blockquote><blockquote><p>Output Areas (OAs) are the lowest level of geographical area for census statistics and were first created following the 2001 Census. Each OA is made up of between 40 and 250 households and a usually resident population of between 100 and 625 persons and may change after each census.</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>population_oa</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>read_csv</span><span class=p>(</span><span class=s1>&#39;data/uk-census-2021-oa.csv&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>population_oa</span><span class=o>.</span><span class=n>head</span><span class=p>()</span>
</span></span></code></pre></div><pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre><p></p><h3 id=geographic-manipulation---oa-boundaries-to-cells>Geographic manipulation&ndash; OA boundaries to cells<a hidden class=anchor aria-hidden=true href=#geographic-manipulation---oa-boundaries-to-cells>#</a></h3><p>To match the above OA codes with actual geography, we have to obtain the boundaries of each output area&ndash; these can be found on <a href="https://geoportal.statistics.gov.uk/datasets/ons::output-areas-dec-2021-boundaries-generalised-clipped-ew-bgc/explore?location=52.593248%2C-2.489483%2C7.00">UK&rsquo;s goverment geoportal</a>&ndash; note that I am using the &lsquo;generalised&rsquo; version instead of the full version.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>boundaries</span> <span class=o>=</span> <span class=n>gpd</span><span class=o>.</span><span class=n>read_file</span><span class=p>(</span><span class=s1>&#39;data/Output_Areas_(Dec_2021)_Boundaries_Generalised_Clipped_EW_(BGC)/Output_Areas_(Dec_2021)_Boundaries_Generalised_Clipped_EW_(BGC).shp&#39;</span><span class=p>)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>boundaries</span><span class=o>.</span><span class=n>head</span><span class=p>()</span>
</span></span></code></pre></div><pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre><p></p><p>In the boundaries geodataframe, the columns we&rsquo;ll need is that &lsquo;OA21CD&rsquo;, &lsquo;Shape_Are&rsquo; and &lsquo;geometry columns&rsquo;: &lsquo;OA21CD&rsquo; can join to the population dataset from above, Shape__Are gives the area of the OA in m^2 (note that this is different from the poulation measurement unit, which is in km^2). We can in fact cross check it against the geometry column</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># check that the projection is indeed british national grid eastings and northings</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;geodata has projection of </span><span class=si>{</span><span class=n>boundaries</span><span class=o>.</span><span class=n>crs</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># check that the geometry gives ~the same area as what shape_are gives to a 10m^2 tolerance</span>
</span></span><span class=line><span class=cl><span class=k>assert</span> <span class=p>((</span><span class=n>boundaries</span><span class=o>.</span><span class=n>area</span><span class=o>.</span><span class=n>astype</span><span class=p>(</span><span class=nb>int</span><span class=p>)</span><span class=o>-</span> <span class=n>boundaries</span><span class=o>.</span><span class=n>Shape__Are</span><span class=o>.</span><span class=n>astype</span><span class=p>(</span><span class=nb>int</span><span class=p>))</span><span class=o>.</span><span class=n>abs</span><span class=p>()</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>)</span><span class=o>.</span><span class=n>sum</span><span class=p>()</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=n>boundaries</span><span class=p>)</span>
</span></span></code></pre></div><pre><code>geodata has projection of epsg:27700
</code></pre><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python></code></pre></div><p>Since we are only interested in Greater London, we can filter out rows from the boundaries dataframe that are outside of the london bounding box.</p><p>We can get the bounding box of london using the OSM query <a href="https://nominatim.openstreetmap.org/search.php?city=london&country=uk&format=jsonv2">https://nominatim.openstreetmap.org/search.php?city=london&country=uk&format=jsonv2</a> (the first entry is the correct one), giving a boundingbox of ymin, ymax, xmin, xmax of &ldquo;51.2867602&rdquo;,&ldquo;51.6918741&rdquo;,"-0.5103751",&ldquo;0.3340155&rdquo;</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>ldn_bounding_box</span> <span class=o>=</span> <span class=n>Polygon</span><span class=o>.</span><span class=n>from_bounds</span><span class=p>(</span> <span class=o>-</span><span class=mf>0.5103751</span><span class=p>,</span> <span class=mf>51.2867602</span><span class=p>,</span><span class=mf>0.3340155</span><span class=p>,</span> <span class=mf>51.691874</span> <span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>ldn_bounding_box</span> <span class=o>=</span> <span class=n>gpd</span><span class=o>.</span><span class=n>GeoSeries</span><span class=p>([</span><span class=n>ldn_bounding_box</span><span class=p>],</span> <span class=n>crs</span><span class=o>=</span><span class=s1>&#39;epsg:4326&#39;</span><span class=p>)</span><span class=o>.</span><span class=n>to_crs</span><span class=p>(</span><span class=n>boundaries</span><span class=o>.</span><span class=n>crs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>ldn_bounding_box</span><span class=o>.</span><span class=n>geometry</span>
</span></span></code></pre></div><pre><code>0    POLYGON ((503976.311 155234.131, 503059.759 20...
dtype: geometry
</code></pre><p>Convert the geodataframe into a grid for downstream tasks&ndash; Ordnance survey actually has a file of british grids at various resolutions prebuilt (<a href=https://github.com/OrdnanceSurvey/OS-British-National-Grids)>https://github.com/OrdnanceSurvey/OS-British-National-Grids)</a>, &ndash; the smallest is 1km by 1km, so we will construct our own 100m x 100m grid for london (We can do it for the whole uk, but we will have to iterate through the dataset as the number of cells will become very large)</p><hr><p><strong>diversion</strong></p><p>This demos how to use the grid gpkg file from OS&ndash; the gpkg is a vector file with multiple &rsquo;layers&rsquo; the same way a raster file can have bands</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># get the layer names</span>
</span></span><span class=line><span class=cl><span class=nb>list</span><span class=p>(</span><span class=n>fiona</span><span class=o>.</span><span class=n>listlayers</span><span class=p>(</span><span class=s1>&#39;data/os_bng_grids.gpkg&#39;</span><span class=p>))</span>
</span></span></code></pre></div><pre><code>['100km_grid', '50km_grid', '20km_grid', '10km_grid', '5km_grid', '1km_grid']
</code></pre><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>layername</span> <span class=o>=</span> <span class=s1>&#39;1km_grid&#39;</span>
</span></span><span class=line><span class=cl><span class=n>bsng_grid_1km</span> <span class=o>=</span> <span class=n>gpd</span><span class=o>.</span><span class=n>read_file</span><span class=p>(</span><span class=s1>&#39;data/os_bng_grids.gpkg&#39;</span><span class=p>,</span> <span class=n>layer</span><span class=o>=</span><span class=n>layername</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>bsng_grid_1km</span><span class=o>.</span><span class=n>head</span><span class=p>()</span>
</span></span></code></pre></div><pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre><p></p><hr><p>Back to our task, we filter out the OA that intersects the london bounding box:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>gpd</span><span class=o>.</span><span class=n>GeoDataFrame</span><span class=p>(</span><span class=n>ldn_bounding_box</span><span class=o>.</span><span class=n>reset_index</span><span class=p>())</span><span class=o>.</span><span class=n>geometry</span>
</span></span></code></pre></div><pre><code>0    POLYGON ((503976.311 155234.131, 503059.759 20...
Name: 0, dtype: geometry
</code></pre><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>ldn_boundaries</span> <span class=o>=</span> <span class=n>boundaries</span><span class=p>[[</span><span class=s1>&#39;OA21CD&#39;</span><span class=p>,</span> <span class=s1>&#39;geometry&#39;</span><span class=p>]]</span><span class=o>.</span><span class=n>sjoin</span><span class=p>(</span><span class=n>gpd</span><span class=o>.</span><span class=n>GeoDataFrame</span><span class=p>(</span><span class=n>ldn_bounding_box</span><span class=o>.</span><span class=n>reset_index</span><span class=p>()),</span> <span class=n>how</span><span class=o>=</span><span class=s1>&#39;inner&#39;</span><span class=p>)[[</span><span class=s1>&#39;OA21CD&#39;</span><span class=p>,</span> <span class=s1>&#39;geometry&#39;</span><span class=p>]]</span>
</span></span><span class=line><span class=cl><span class=n>ldn_boundaries</span><span class=o>.</span><span class=n>head</span><span class=p>()</span>
</span></span></code></pre></div><pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre><p></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>ldn_bounding_box</span><span class=o>.</span><span class=n>geometry</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>bounds</span>
</span></span></code></pre></div><pre><code>(503059.75944664044, 155234.13110756868, 562854.9611320551, 201813.5769950911)
</code></pre><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># create a 100m by 100m grid for london</span>
</span></span><span class=line><span class=cl><span class=n>cellsize</span><span class=o>=</span><span class=mi>100</span>
</span></span><span class=line><span class=cl><span class=c1># British National Grid extent (0,0 700000,1300000)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>xmin</span><span class=p>,</span> <span class=n>ymin</span><span class=p>,</span>  <span class=n>xmax</span><span class=p>,</span> <span class=n>ymax</span> <span class=o>=</span> <span class=p>[</span><span class=mi>100</span> <span class=o>*</span> <span class=p>(</span><span class=n>x</span><span class=o>//</span><span class=mi>100</span> <span class=p>)</span><span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>ldn_bounding_box</span><span class=o>.</span><span class=n>geometry</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>bounds</span><span class=p>]</span> 
</span></span><span class=line><span class=cl><span class=n>matrix</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>mgrid</span><span class=p>[</span><span class=nb>int</span><span class=p>(</span><span class=n>xmin</span><span class=p>):</span><span class=nb>int</span><span class=p>(</span><span class=n>xmax</span> <span class=o>+</span> <span class=n>cellsize</span><span class=p>):</span><span class=n>cellsize</span><span class=p>,</span> <span class=nb>int</span><span class=p>(</span><span class=n>ymin</span><span class=p>):</span><span class=nb>int</span><span class=p>(</span><span class=n>ymax</span><span class=o>+</span> <span class=n>cellsize</span><span class=p>):</span><span class=n>cellsize</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>xcoor</span> <span class=o>=</span> <span class=n>matrix</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>flatten</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>ycoor</span> <span class=o>=</span> <span class=n>matrix</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>flatten</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>xcoor_max</span> <span class=o>=</span> <span class=n>xcoor</span> <span class=o>+</span><span class=n>cellsize</span>
</span></span><span class=line><span class=cl><span class=n>ycoor_max</span> <span class=o>=</span> <span class=n>ycoor</span> <span class=o>+</span> <span class=n>cellsize</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>polygons</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>xmax</span><span class=p>,</span> <span class=n>ymax</span> <span class=ow>in</span> <span class=n>tqdm</span><span class=p>(</span><span class=nb>zip</span> <span class=p>(</span><span class=n>xcoor</span><span class=p>,</span> <span class=n>ycoor</span><span class=p>,</span> <span class=n>xcoor_max</span><span class=p>,</span> <span class=n>ycoor_max</span><span class=p>),</span> <span class=n>total</span><span class=o>=</span><span class=nb>len</span><span class=p>(</span><span class=n>ycoor</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>    <span class=n>polygons</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>Polygon</span><span class=o>.</span><span class=n>from_bounds</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>xmax</span><span class=p>,</span> <span class=n>ymax</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>grid</span> <span class=o>=</span> <span class=n>gpd</span><span class=o>.</span><span class=n>GeoDataFrame</span><span class=p>(</span><span class=n>data</span><span class=o>=</span><span class=p>{</span><span class=s1>&#39;cellid&#39;</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>polygons</span><span class=p>))},</span><span class=n>geometry</span><span class=o>=</span><span class=n>polygons</span><span class=p>,</span> <span class=n>crs</span><span class=o>=</span><span class=n>boundaries</span><span class=o>.</span><span class=n>crs</span><span class=p>)</span>
</span></span></code></pre></div><pre><code>100%|████████████████████████████████| 279733/279733 [00:04&lt;00:00, 65379.51it/s]
</code></pre><p>Join the grid to the OA polygons to get the demographics info per grid cell</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>grid</span><span class=o>.</span><span class=n>shape</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>ldn_boundaries</span><span class=o>.</span><span class=n>shape</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ldn_demographics_grid</span> <span class=o>=</span> <span class=n>grid</span><span class=o>.</span><span class=n>sjoin</span><span class=p>(</span><span class=n>boundaries</span><span class=p>)</span>
</span></span></code></pre></div><pre><code>(279733, 2)
(30160, 2)
</code></pre><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>ldn_demographics_grid</span>
</span></span></code></pre></div><pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre><p></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># as we can see, the OA size span is quite large --luckily most OA are larger than a grid cell. </span>
</span></span><span class=line><span class=cl><span class=n>ax</span> <span class=o>=</span><span class=n>ldn_demographics_grid</span><span class=o>.</span><span class=n>drop_duplicates</span><span class=p>(</span><span class=n>subset</span><span class=o>=</span><span class=s1>&#39;OA21CD&#39;</span><span class=p>)</span><span class=o>.</span><span class=n>Shape__Are</span><span class=o>.</span><span class=n>apply</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>log10</span><span class=p>)</span><span class=o>.</span><span class=n>hist</span><span class=p>(</span><span class=n>bins</span> <span class=o>=</span> <span class=mi>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>ax</span><span class=o>.</span><span class=n>set_xlabel</span><span class=p>(</span><span class=s1>&#39;OA area m^2&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>ax</span><span class=o>.</span><span class=n>set_ylabel</span><span class=p>(</span><span class=s1>&#39;number of OA&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>ax</span><span class=o>.</span><span class=n>vlines</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=mi>1800</span><span class=p>,</span> <span class=n>colors</span><span class=o>=</span><span class=s1>&#39;b&#39;</span><span class=p>,</span> <span class=n>label</span><span class=o>=</span><span class=s1>&#39;10,000 m^2 (Size of cell)&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>ax</span><span class=o>.</span><span class=n>legend</span><span class=p>()</span>
</span></span></code></pre></div><pre><code>&lt;matplotlib.legend.Legend at 0x7f8b0b33e680&gt;
</code></pre><p><img loading=lazy src=https://wwymak.github.io/2023-02-01-uk-population-census-2021/output_26_1.png alt=png></p><p>There are clearly duplicates&ndash; e.g. when a grid cell span more than 1 OA, and where 1OA span more than 1cell&ndash; this is more likely for the OA to span mutliple cells than the other way round. Base on this assumption, we assign each cell to one OA by dropping duplicadtes</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>ldn_demographics_grid</span> <span class=o>=</span> <span class=n>ldn_demographics_grid</span><span class=o>.</span><span class=n>drop_duplicates</span><span class=p>(</span><span class=n>subset</span><span class=o>=</span><span class=s1>&#39;cellid&#39;</span><span class=p>)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># drop all the unneed cols</span>
</span></span><span class=line><span class=cl><span class=n>ldn_demographics_grid</span> <span class=o>=</span> <span class=n>ldn_demographics_grid</span><span class=p>[[</span><span class=s1>&#39;cellid&#39;</span><span class=p>,</span> <span class=s1>&#39;OA21CD&#39;</span><span class=p>,</span> <span class=s1>&#39;geometry&#39;</span><span class=p>]]</span>
</span></span></code></pre></div><p>Finally, let&rsquo;s populate these grid cells with demographic data</p><ul><li><a href=https://www.ons.gov.uk/datasets/TS017/editions/2021/versions/2/filter-outputs/1799bd24-15d0-43ca-81d4-bccb7434f0d4#get-data>household size by OA</a></li><li><a href=https://www.ons.gov.uk/datasets/TS067/editions/2021/versions/1/filter-outputs/55e2442d-5a41-4ca2-872f-030d52af39d7#get-data>education</a></li><li>[population density]((<a href=https://www.ons.gov.uk/filters/b9532b29-299e-4a23-9fc8-b99d68e172b9/dimensions>https://www.ons.gov.uk/filters/b9532b29-299e-4a23-9fc8-b99d68e172b9/dimensions</a>)</li><li><a href=https://www.ons.gov.uk/datasets/TS008/editions/2021/versions/3/filter-outputs/4f979d87-7e23-4e29-83ed-db14647e92ba#get-data>sex</a></li></ul><p>We have discussed the population data above, let&rsquo;s now tidy up the other datasets</p><h4 id=household-size>household size<a hidden class=anchor aria-hidden=true href=#household-size>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>houshold</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>read_csv</span><span class=p>(</span><span class=s1>&#39;data/household_size_output_area_census2021.csv&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>houshold</span><span class=o>.</span><span class=n>head</span><span class=p>()</span>
</span></span></code></pre></div><pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre><p></p><p>We can use the &lsquo;code&rsquo; as a proxy for household size</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>houshold</span><span class=p>[[</span><span class=s1>&#39;Household size (9 categories)&#39;</span><span class=p>,</span> <span class=s1>&#39;Household size (9 categories) Code&#39;</span><span class=p>]]</span><span class=o>.</span><span class=n>drop_duplicates</span><span class=p>()</span>
</span></span></code></pre></div><pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre><p></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>mean_household_size</span> <span class=o>=</span> <span class=n>houshold</span><span class=p>[[</span><span class=s1>&#39;Output Areas Code&#39;</span><span class=p>,</span> <span class=s1>&#39;Household size (9 categories) Code&#39;</span><span class=p>,</span><span class=s1>&#39;Observation&#39;</span><span class=p>]]</span>
</span></span><span class=line><span class=cl><span class=n>mean_household_size</span><span class=p>[</span><span class=s1>&#39;counts&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=n>mean_household_size</span><span class=p>[</span><span class=s1>&#39;Household size (9 categories) Code&#39;</span><span class=p>]</span> <span class=o>*</span> <span class=n>mean_household_size</span><span class=p>[</span><span class=s1>&#39;Observation&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>mean_household_size</span> <span class=o>=</span> <span class=n>mean_household_size</span><span class=o>.</span><span class=n>groupby</span><span class=p>(</span><span class=s1>&#39;Output Areas Code&#39;</span><span class=p>)[</span><span class=s1>&#39;counts&#39;</span><span class=p>]</span><span class=o>.</span><span class=n>sum</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>mean_household_size_totals</span> <span class=o>=</span> <span class=n>houshold</span><span class=p>[[</span><span class=s1>&#39;Output Areas Code&#39;</span><span class=p>,</span> <span class=s1>&#39;Household size (9 categories) Code&#39;</span><span class=p>,</span><span class=s1>&#39;Observation&#39;</span><span class=p>]]</span><span class=o>.</span><span class=n>groupby</span><span class=p>(</span><span class=s1>&#39;Output Areas Code&#39;</span><span class=p>)[</span><span class=s1>&#39;Observation&#39;</span><span class=p>]</span><span class=o>.</span><span class=n>sum</span><span class=p>()</span>
</span></span></code></pre></div><pre><code>/tmp/ipykernel_28838/2961719914.py:2: SettingWithCopyWarning: 
A value is trying to be set on a copy of a slice from a DataFrame.
Try using .loc[row_indexer,col_indexer] = value instead

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy
  mean_household_size['counts'] = mean_household_size['Household size (9 categories) Code'] * mean_household_size['Observation']
</code></pre><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>mean_household_size</span><span class=o>.</span><span class=n>reset_index</span><span class=p>()</span>
</span></span></code></pre></div><pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre><p></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>mean_household_size</span> <span class=o>=</span> <span class=n>mean_household_size</span><span class=o>.</span><span class=n>reset_index</span><span class=p>()</span><span class=o>.</span><span class=n>merge</span><span class=p>(</span><span class=n>mean_household_size_totals</span><span class=o>.</span><span class=n>reset_index</span><span class=p>(),</span> <span class=n>on</span><span class=o>=</span><span class=s1>&#39;Output Areas Code&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>mean_household_size</span><span class=p>[</span><span class=s1>&#39;avg_household_size&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=n>mean_household_size</span><span class=p>[</span><span class=s1>&#39;counts&#39;</span><span class=p>]</span> <span class=o>/</span>  <span class=n>mean_household_size</span><span class=p>[</span><span class=s1>&#39;Observation&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>mean_household_size</span><span class=o>.</span><span class=n>head</span><span class=p>()</span>
</span></span></code></pre></div><pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre><p></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python></code></pre></div><h4 id=gender>gender<a hidden class=anchor aria-hidden=true href=#gender>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>gender</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>read_csv</span><span class=p>(</span><span class=s1>&#39;data/uk-census-2021-sex-oa.csv&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>gender</span><span class=o>.</span><span class=n>head</span><span class=p>()</span>
</span></span></code></pre></div><pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre><p></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>females</span> <span class=o>=</span> <span class=n>gender</span><span class=p>[</span><span class=n>gender</span><span class=p>[</span><span class=s1>&#39;Sex (2 categories)&#39;</span><span class=p>]</span> <span class=o>==</span> <span class=s1>&#39;Female&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>gender_total</span> <span class=o>=</span> <span class=n>gender</span><span class=o>.</span><span class=n>groupby</span><span class=p>([</span><span class=s1>&#39;Output Areas Code&#39;</span><span class=p>])[</span><span class=s1>&#39;Observation&#39;</span><span class=p>]</span><span class=o>.</span><span class=n>sum</span><span class=p>()</span><span class=o>.</span><span class=n>reset_index</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>percent_female</span> <span class=o>=</span> <span class=n>females</span><span class=p>[[</span><span class=s1>&#39;Output Areas&#39;</span><span class=p>,</span> <span class=s1>&#39;Observation&#39;</span><span class=p>]]</span><span class=o>.</span><span class=n>merge</span><span class=p>(</span><span class=n>gender_total</span><span class=p>,</span> <span class=n>left_on</span><span class=o>=</span><span class=s1>&#39;Output Areas&#39;</span><span class=p>,</span> <span class=n>right_on</span><span class=o>=</span><span class=s1>&#39;Output Areas Code&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>percent_female</span><span class=p>[</span><span class=s1>&#39;pct&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=n>percent_female</span><span class=p>[</span><span class=s1>&#39;Observation_x&#39;</span><span class=p>]</span> <span class=o>/</span> <span class=n>percent_female</span><span class=p>[</span><span class=s1>&#39;Observation_y&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>percent_female</span><span class=o>.</span><span class=n>head</span><span class=p>()</span>
</span></span></code></pre></div><pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre><p></p><h4 id=education>education<a hidden class=anchor aria-hidden=true href=#education>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>education</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>read_csv</span><span class=p>(</span><span class=s1>&#39;data/uk-census-2021-education-oa.csv&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>education</span><span class=o>.</span><span class=n>head</span><span class=p>()</span>
</span></span></code></pre></div><pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre><p></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>education</span><span class=p>[[</span><span class=s1>&#39;Highest level of qualification (8 categories) Code&#39;</span><span class=p>,</span><span class=s1>&#39;Highest level of qualification (8 categories)&#39;</span>	<span class=p>]]</span><span class=o>.</span><span class=n>drop_duplicates</span><span class=p>()</span>
</span></span></code></pre></div><pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre><p></p><p>here make the simplifying assumption that we ignore the &lsquo;does not apply category&rsquo;, and the categories code go up in more advanced education</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>mean_education_level</span> <span class=o>=</span> <span class=n>education</span><span class=p>[[</span><span class=s1>&#39;Output Areas Code&#39;</span><span class=p>,</span> <span class=s1>&#39;Highest level of qualification (8 categories) Code&#39;</span><span class=p>,</span><span class=s1>&#39;Observation&#39;</span><span class=p>]]</span>
</span></span><span class=line><span class=cl><span class=n>mean_education_level</span><span class=p>[</span><span class=s1>&#39;counts&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=n>mean_education_level</span><span class=p>[</span><span class=s1>&#39;Highest level of qualification (8 categories) Code&#39;</span><span class=p>]</span><span class=o>.</span><span class=n>clip</span><span class=p>(</span><span class=n>lower</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span> <span class=o>*</span> <span class=n>mean_education_level</span><span class=p>[</span><span class=s1>&#39;Observation&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>mean_education_level</span> <span class=o>=</span> <span class=n>mean_education_level</span><span class=o>.</span><span class=n>groupby</span><span class=p>(</span><span class=s1>&#39;Output Areas Code&#39;</span><span class=p>)[</span><span class=s1>&#39;counts&#39;</span><span class=p>]</span><span class=o>.</span><span class=n>sum</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>mean_education_level_totals</span> <span class=o>=</span> <span class=n>education</span><span class=p>[[</span><span class=s1>&#39;Output Areas Code&#39;</span><span class=p>,</span> <span class=s1>&#39;Highest level of qualification (8 categories) Code&#39;</span><span class=p>,</span><span class=s1>&#39;Observation&#39;</span><span class=p>]]</span><span class=o>.</span><span class=n>groupby</span><span class=p>(</span><span class=s1>&#39;Output Areas Code&#39;</span><span class=p>)[</span><span class=s1>&#39;Observation&#39;</span><span class=p>]</span><span class=o>.</span><span class=n>sum</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>mean_education_level</span> <span class=o>=</span> <span class=n>mean_education_level</span><span class=o>.</span><span class=n>reset_index</span><span class=p>()</span><span class=o>.</span><span class=n>merge</span><span class=p>(</span><span class=n>mean_education_level_totals</span><span class=o>.</span><span class=n>reset_index</span><span class=p>(),</span> <span class=n>on</span><span class=o>=</span><span class=s1>&#39;Output Areas Code&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>mean_education_level</span><span class=p>[</span><span class=s1>&#39;avg_education_level&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=n>mean_education_level</span><span class=p>[</span><span class=s1>&#39;counts&#39;</span><span class=p>]</span> <span class=o>/</span>  <span class=n>mean_education_level</span><span class=p>[</span><span class=s1>&#39;Observation&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>mean_education_level</span><span class=o>.</span><span class=n>head</span><span class=p>()</span>
</span></span></code></pre></div><pre><code>/tmp/ipykernel_28838/566605148.py:2: SettingWithCopyWarning: 
A value is trying to be set on a copy of a slice from a DataFrame.
Try using .loc[row_indexer,col_indexer] = value instead

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy
  mean_education_level['counts'] = mean_education_level['Highest level of qualification (8 categories) Code'].clip(lower=0) * mean_education_level['Observation']
</code></pre><pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre><p></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># add education level info</span>
</span></span><span class=line><span class=cl><span class=n>ldn_demographics_grid_processed</span> <span class=o>=</span> <span class=n>ldn_demographics_grid</span><span class=o>.</span><span class=n>merge</span><span class=p>(</span><span class=n>mean_education_level</span><span class=p>[[</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;Output Areas Code&#39;</span><span class=p>,</span> <span class=s1>&#39;avg_education_level&#39;</span><span class=p>]],</span> <span class=n>left_on</span><span class=o>=</span><span class=s1>&#39;OA21CD&#39;</span><span class=p>,</span> <span class=n>right_on</span><span class=o>=</span><span class=s1>&#39;Output Areas Code&#39;</span><span class=p>)</span><span class=o>.</span><span class=n>drop</span><span class=p>(</span><span class=n>columns</span><span class=o>=</span><span class=s1>&#39;Output Areas Code&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># add % female</span>
</span></span><span class=line><span class=cl><span class=n>ldn_demographics_grid_processed</span> <span class=o>=</span> <span class=n>ldn_demographics_grid_processed</span><span class=o>.</span><span class=n>merge</span><span class=p>(</span><span class=n>percent_female</span><span class=p>[[</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;Output Areas Code&#39;</span><span class=p>,</span> <span class=s1>&#39;pct&#39;</span><span class=p>]],</span> <span class=n>left_on</span><span class=o>=</span><span class=s1>&#39;OA21CD&#39;</span><span class=p>,</span> <span class=n>right_on</span><span class=o>=</span><span class=s1>&#39;Output Areas Code&#39;</span><span class=p>)</span><span class=o>.</span><span class=n>drop</span><span class=p>(</span><span class=n>columns</span><span class=o>=</span><span class=s1>&#39;Output Areas Code&#39;</span><span class=p>)</span><span class=o>.</span><span class=n>rename</span><span class=p>(</span><span class=n>columns</span><span class=o>=</span><span class=p>{</span><span class=s1>&#39;pct&#39;</span><span class=p>:</span> <span class=s1>&#39;pct_females&#39;</span><span class=p>})</span>
</span></span><span class=line><span class=cl><span class=c1># add mean household size</span>
</span></span><span class=line><span class=cl><span class=n>ldn_demographics_grid_processed</span> <span class=o>=</span> <span class=n>ldn_demographics_grid_processed</span><span class=o>.</span><span class=n>merge</span><span class=p>(</span><span class=n>mean_household_size</span><span class=p>[[</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;Output Areas Code&#39;</span><span class=p>,</span> <span class=s1>&#39;avg_household_size&#39;</span><span class=p>]],</span> <span class=n>left_on</span><span class=o>=</span><span class=s1>&#39;OA21CD&#39;</span><span class=p>,</span> <span class=n>right_on</span><span class=o>=</span><span class=s1>&#39;Output Areas Code&#39;</span><span class=p>)</span><span class=o>.</span><span class=n>drop</span><span class=p>(</span><span class=n>columns</span><span class=o>=</span><span class=s1>&#39;Output Areas Code&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ldn_demographics_grid_processed</span> <span class=o>=</span> <span class=n>ldn_demographics_grid_processed</span><span class=o>.</span><span class=n>merge</span><span class=p>(</span><span class=n>population_oa</span><span class=p>[[</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;Output Areas Code&#39;</span><span class=p>,</span> <span class=s1>&#39;Observation&#39;</span><span class=p>]],</span> <span class=n>left_on</span><span class=o>=</span><span class=s1>&#39;OA21CD&#39;</span><span class=p>,</span> <span class=n>right_on</span><span class=o>=</span><span class=s1>&#39;Output Areas Code&#39;</span><span class=p>)</span><span class=o>.</span><span class=n>drop</span><span class=p>(</span><span class=n>columns</span><span class=o>=</span><span class=s1>&#39;Output Areas Code&#39;</span><span class=p>)</span><span class=o>.</span><span class=n>rename</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>columns</span><span class=o>=</span><span class=p>{</span><span class=s1>&#39;Observation&#39;</span><span class=p>:</span> <span class=s1>&#39;pop_density&#39;</span><span class=p>})</span>
</span></span><span class=line><span class=cl><span class=n>ldn_demographics_grid_processed</span><span class=p>[</span><span class=s1>&#39;popoulation&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=n>ldn_demographics_grid_processed</span><span class=p>[</span><span class=s1>&#39;pop_density&#39;</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=mi>100</span> <span class=o>*</span> <span class=mi>100</span><span class=p>)</span><span class=o>/</span><span class=p>(</span><span class=mi>1000</span> <span class=o>*</span> <span class=mi>1000</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>ldn_demographics_grid_processed</span><span class=o>.</span><span class=n>head</span><span class=p>()</span>
</span></span></code></pre></div><pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre><p></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>ldn_demographics_grid_processed</span><span class=o>.</span><span class=n>to_file</span><span class=p>(</span><span class=s1>&#39;data/ldn_demographics_grid_processed.shp&#39;</span><span class=p>)</span>
</span></span></code></pre></div><pre><code>/tmp/ipykernel_28838/324827064.py:1: UserWarning: Column names longer than 10 characters will be truncated when saved to ESRI Shapefile.
  ldn_demographics_grid_processed.to_file('data/ldn_demographics_grid_processed.shp')
</code></pre><h3 id=rasterizing-geodataframe>Rasterizing geodataframe<a hidden class=anchor aria-hidden=true href=#rasterizing-geodataframe>#</a></h3><p>Certain tools work better with raster data, and since we have converted our data from a irregular geometry into cells, we can go all the way and convert the vector data into raster, using <a href=https://corteva.github.io/geocube>geocube</a>.</p><p><strong>Capping/binning population values</strong></p><p>The population values have a fairly long tail&ndash; let&rsquo;s cap this so it is easier to plot and handle</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># printing out some stats -- we can see 95% cells have &lt; 150 people</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ldn_demographics_grid_processed</span><span class=p>[</span><span class=s1>&#39;popoulation&#39;</span><span class=p>]</span><span class=o>.</span><span class=n>quantile</span><span class=p>([</span><span class=mf>0.2</span><span class=p>,</span> <span class=mf>0.4</span><span class=p>,</span> <span class=mf>0.6</span><span class=p>,</span> <span class=mf>0.8</span><span class=p>]),</span><span class=n>ldn_demographics_grid_processed</span><span class=p>[</span><span class=s1>&#39;popoulation&#39;</span><span class=p>]</span><span class=o>.</span><span class=n>quantile</span><span class=p>([</span><span class=mf>0.05</span><span class=p>]),</span>  <span class=n>ldn_demographics_grid_processed</span><span class=p>[</span><span class=s1>&#39;popoulation&#39;</span><span class=p>]</span><span class=o>.</span><span class=n>quantile</span><span class=p>([</span><span class=mf>0.95</span><span class=p>]),</span> <span class=n>ldn_demographics_grid_processed</span><span class=p>[</span><span class=s1>&#39;popoulation&#39;</span><span class=p>]</span><span class=o>.</span><span class=n>min</span><span class=p>(),</span> <span class=n>ldn_demographics_grid_processed</span><span class=p>[</span><span class=s1>&#39;popoulation&#39;</span><span class=p>]</span><span class=o>.</span><span class=n>max</span><span class=p>()</span>
</span></span></code></pre></div><pre><code>(0.2     1.024
 0.4     4.157
 0.6    21.138
 0.8    62.500
 Name: popoulation, dtype: float64,
 0.05    0.321
 Name: popoulation, dtype: float64,
 0.95    130.5817
 Name: popoulation, dtype: float64,
 0.156,
 2393.333)
</code></pre><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>ldn_demographics_grid_processed</span><span class=p>[</span><span class=s1>&#39;popoulation&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=n>ldn_demographics_grid_processed</span><span class=p>[</span><span class=s1>&#39;popoulation&#39;</span><span class=p>]</span><span class=o>.</span><span class=n>clip</span><span class=p>(</span><span class=n>lower</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>upper</span><span class=o>=</span><span class=mi>150</span><span class=p>)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>ldn_demographics_grid_processed</span><span class=p>[</span><span class=s1>&#39;popoulation&#39;</span><span class=p>]</span><span class=o>.</span><span class=n>max</span><span class=p>()</span>
</span></span></code></pre></div><pre><code>150.0
</code></pre><p>Now we convert the vector to raster (the resolution is what we are using for each of our cells&ndash; 100m )</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>ldn_demographics_raster</span> <span class=o>=</span> <span class=n>make_geocube</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>vector_data</span><span class=o>=</span><span class=n>ldn_demographics_grid_processed</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>measurements</span><span class=o>=</span><span class=p>[</span><span class=s2>&#34;popoulation&#34;</span><span class=p>,</span> <span class=s2>&#34;avg_education_level&#34;</span><span class=p>,</span> <span class=s2>&#34;pct_females&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=n>resolution</span><span class=o>=</span><span class=p>(</span><span class=o>-</span><span class=mi>100</span><span class=p>,</span> <span class=mi>100</span><span class=p>),</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>ldn_demographics_raster</span><span class=p>[</span><span class=s1>&#39;popoulation&#39;</span><span class=p>]</span><span class=o>.</span><span class=n>plot</span><span class=p>()</span>
</span></span></code></pre></div><pre><code>&lt;matplotlib.collections.QuadMesh at 0x7f8adde759c0&gt;
</code></pre><p><img loading=lazy src=https://wwymak.github.io/2023-02-01-uk-population-census-2021/output_56_1.png alt=png></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>ldn_demographics_raster</span><span class=p>[</span><span class=s1>&#39;pct_females&#39;</span><span class=p>]</span><span class=o>.</span><span class=n>plot</span><span class=p>()</span>
</span></span></code></pre></div><pre><code>&lt;matplotlib.collections.QuadMesh at 0x7f8b0c795db0&gt;
</code></pre><p><img loading=lazy src=https://wwymak.github.io/2023-02-01-uk-population-census-2021/output_57_1.png alt=png></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>ldn_demographics_raster</span><span class=p>[</span><span class=s1>&#39;avg_education_level&#39;</span><span class=p>]</span><span class=o>.</span><span class=n>plot</span><span class=p>()</span>
</span></span></code></pre></div><pre><code>&lt;matplotlib.collections.QuadMesh at 0x7f8b0d76e2f0&gt;
</code></pre><p><img loading=lazy src=https://wwymak.github.io/2023-02-01-uk-population-census-2021/output_58_1.png alt=png></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># save our raster data</span>
</span></span><span class=line><span class=cl><span class=n>ldn_demographics_raster</span><span class=o>.</span><span class=n>rio</span><span class=o>.</span><span class=n>to_raster</span><span class=p>(</span><span class=s2>&#34;data/ldn_demographics_raster.tiff&#34;</span><span class=p>)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://wwymak.github.io/tags/python/>python</a></li><li><a href=https://wwymak.github.io/tags/geospatial/>geospatial</a></li><li><a href=https://wwymak.github.io/tags/census/>census</a></li></ul><nav class=paginav><a class=prev href=https://wwymak.github.io/tech/2023-01-15-rasterio-tips-and-tricks/><span class=title>« Prev</span><br><span>Geo raster data parsing with rasterio</span></a>
<a class=next href=https://wwymak.github.io/tech/2021-11-13-tf-check-gpu/><span class=title>Next »</span><br><span>How to check if your deep learning library is actually using the GPU</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Processing UK 2021 census open data with python tools on twitter" href="https://twitter.com/intent/tweet/?text=Processing%20UK%202021%20census%20open%20data%20with%20python%20tools&url=https%3a%2f%2fwwymak.github.io%2ftech%2f2023-02-01-uk-population-census-2021%2f&hashtags=python%2cgeospatial%2ccensus"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Processing UK 2021 census open data with python tools on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fwwymak.github.io%2ftech%2f2023-02-01-uk-population-census-2021%2f&title=Processing%20UK%202021%20census%20open%20data%20with%20python%20tools&summary=Processing%20UK%202021%20census%20open%20data%20with%20python%20tools&source=https%3a%2f%2fwwymak.github.io%2ftech%2f2023-02-01-uk-population-census-2021%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Processing UK 2021 census open data with python tools on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwwymak.github.io%2ftech%2f2023-02-01-uk-population-census-2021%2f&title=Processing%20UK%202021%20census%20open%20data%20with%20python%20tools"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Processing UK 2021 census open data with python tools on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwwymak.github.io%2ftech%2f2023-02-01-uk-population-census-2021%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Processing UK 2021 census open data with python tools on whatsapp" href="https://api.whatsapp.com/send?text=Processing%20UK%202021%20census%20open%20data%20with%20python%20tools%20-%20https%3a%2f%2fwwymak.github.io%2ftech%2f2023-02-01-uk-population-census-2021%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Processing UK 2021 census open data with python tools on telegram" href="https://telegram.me/share/url?text=Processing%20UK%202021%20census%20open%20data%20with%20python%20tools&url=https%3a%2f%2fwwymak.github.io%2ftech%2f2023-02-01-uk-population-census-2021%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://wwymak.github.io></a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>